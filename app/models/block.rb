class Block < ActiveRecord::Base
  # We'll mostly want blocks ordered by solving time
  default_scope order("found_at DESC")

  # A block has many contributions from different workers
  # (unless found by a PPS worker, in which case we keep the generated coins)
  has_many :contributions,
    :dependent => :destroy

  # The share that provided the winning solution
  belongs_to :share

  validates :found_at,
    :presence => true

  # This is the big endian block hash
  validates :checksum,
    :presence => true,
    :uniqueness => true

  validates :generated,
    :presence => true,
    :inclusion => { :in => [1..21000000]}

  # Whether the block is actually confirmed and its coins have matured
  def confirmed?
    confirmations >= 120
  end

  # Scope on blocks that have no contributions recorded
  def self.without_contributions
    where("NOT EXISTS (SELECT * FROM `contributions` WHERE `contributions`.`block_id`=`blocks`.`id`) ")
  end

  # Scope on blocks that were generated by non-PPS workers
  def self.non_pps
    where(:pps => false)
  end

  # Returns the ID of the first share in the round
  def first_share_of_round_id
    previous_round_last_share_id = Share.
      where("id < ?", block.share.id).
      non_pps.
      where("id IN (SELECT `blocks`.`share_id` FROM `blocks`)").
      maximum(:id)

    if previous_round_last_share_id
      Share.non_pps.where("id > ,", previous_round_last_share_id).minimum(:id)
    else
      Share.non_pps.minimum(:id)
    end
  end

  # Splits the generated coins among the contributors
  def split_the_money!
    to_split = generated
  end

  # Records new blocks based on shares that the upstream bitcoin client
  # recognized as a valid block solution
  def self.fetch_new
    Share.where(:upstream_result => "Y").all.each do |share|
      b = BlockHeader.new(share.solution)

      if Block.where(:checksum => b.hash).count.zero?
        b = Block.create!({
            :found_at => Time.at(b.timestamp),
            :checksum => b.hash,
            :share => share,
            :pps => share.worker.pps
          }
        )
      end
    end
  end

  # Updates the block confirmations based on the confirmations of the
  # generation transaction
  def self.update_confirmations
    Block.where("confirmations < ?", 120).each do |block|
      btc = Bitcoin::Client.new
      blk = btc.get_block_by_hash(block.checksum)
      
      # This assumes the generation tx is always the first in the tx array
      tx  = btc.get_transaction(blk["tx"][0]["hash"])

      block.update_attributes!({
          :confirmations => tx["confirmations"],
          :generated => tx["amount"]
        }
      )
    end
  end

  # Creates contributions based on submitted shares for each round, this
  # is where we calculate the exact rewards (for the normal case)
  # We do not handle contributions for PPS blocks since we're already paying
  # a fixed amount for these shares
  def self.create_contributions
    # For each block that has no contributions and is not pps?
    # # Create contributions based upon submitted shares
    # # Record found_block flag correctly

    Block.
      without_contributions.
      non_pps.
      all.
      each do |block|

      # Change this to account differently for shares, "1" will count 1 for each
      # share.
      scoring_function = "1"

      # Another possibility for a scoring function which makes old shares less
      # valuable
      # scoring_function = (1.0 / (UNIX_TIMESTAMP(CURRENT_TIMESTAMP) - UNIX_TIMESTAMP(created_at) + 10))

      Share.relevant_to(block).
        select("username").
        select("SUM(#{scoring_function}) AS score").
        select("MAX(upstream_result) AS found_block").
        all.each do |contribution|

        Contribution.create!(
          :block => block,
          :worker => Worker.find_by_username(contribution['username']),
          :found_block => (contribution['found_block'] == "Y"),
          :score => contribution['score']
        )
      end

      Share.relevant_to(block).delete_all

      block.split_the_money!
    end
  end
end
